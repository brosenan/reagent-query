
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en-us">

  <head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">

  <!-- Enable responsiveness on mobile devices-->
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">
  <link rel="shortcut icon" href="favicon.ico">
  <title>reagent-query.reagent-query - Test helpers for reagent code</title>
  <script src="js/highlight.min.js"></script>
  <script src="js/gumshoe.min.js"></script>
  <script src="js/smooth-scroll.min.js"></script>
  
  <!-- CSS -->
  <link rel="stylesheet" href="css/poole.css">
  <link rel="stylesheet" href="css/syntax.css">
  <link rel="stylesheet" href="css/lanyon.css">
  <link rel="stylesheet" href="css/bolton.css">
  <link rel="stylesheet" href="css/bolton-api.css">
  <link rel="stylesheet" href="css/bolton-highlight.css">
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=PT+Serif:400,400italic,700|PT+Sans:400">
  
</head>

  <body class="theme-base-08">
    <span id="page-top"></span>

    <!-- Target for toggling the sidebar `.sidebar-checkbox` is for regular
     styles, `#sidebar-checkbox` for behavior. -->
<input type="checkbox" class="sidebar-checkbox" id="sidebar-checkbox">

<!-- Toggleable sidebar -->
<div class="sidebar" id="sidebar">
  <nav class="sidebar-nav">
    <span>&nbsp;</span>
    <a class="sidebar-nav-item header" href="index.html"><img src="img/logo-white.png"/></a>
    <span>&nbsp;</span>
    <a class="sidebar-nav-item active" href="core.html">reagent-query</a>
    <span class="sidebar-nav-item">&nbsp;</span>
    <span class="sidebar-nav-item">&nbsp;</span>
  </nav>
</div>


    <!-- Wrap is the content to shift when toggling the sidebar. We wrap the
         content to avoid any CSS collisions with our real content. -->
    <div class="wrap">
      <div class="masthead">
        <div class="container">
          <h3 class="masthead-title">
            <span>reagent-query</span>
            <small>Test helpers for reagent code</small>
          </h3>
        </div>
      </div>

      <div class="container content">
        <div class="page">
          <div class="heading">
            <div>
              <h5>Author: Boaz Rosenan</h5>
              <h5>Date: 07 October 2017</h5>
              <h5>Repository: <a href="https://github.com/brosenan/reagent-query">https://github.com/brosenan/reagent-query</a></h5>
              <h5>Version: 0.1.1-SNAPSHOT</h5></div></div>
          <hr/>
          <div class="outline">
            <div class="toc">
              <nav data-gumshoe-header>
                <ul data-gumshoe>
                  <a data-scroll class="top" href="#page-top">TOP</a>
                  <li><a class="chapter" data-scroll="" href="#introduction"><h4>1 &nbsp; Introduction</h4></a><a class="section" data-scroll="" href="#the-problem"><h5><i>1.1 &nbsp; The Problem</i></h5></a><a class="section" data-scroll="" href="#the-solution"><h5><i>1.2 &nbsp; The Solution</i></h5></a><a class="section" data-scroll="" href="#example"><h5><i>1.3 &nbsp; Example</i></h5></a></li><li><a class="chapter" data-scroll="" href="#query"><h4>2 &nbsp; query</h4></a><a class="section" data-scroll="" href="#paths"><h5><i>2.1 &nbsp; Paths</i></h5></a><a class="section" data-scroll="" href="#classes"><h5><i>2.2 &nbsp; Classes</i></h5></a></li><li><a class="chapter" data-scroll="" href="#mock-change-event"><h4>3 &nbsp; mock-change-event</h4></a></li>
                </ul>
              </nav>
            </div>
          </div>

          <div class="toc">
              <nav>
                <ul>
                  <li><a class="chapter" data-scroll="" href="#introduction"><h4>1 &nbsp; Introduction</h4></a><a class="section" data-scroll="" href="#the-problem"><h5><i>1.1 &nbsp; The Problem</i></h5></a><a class="section" data-scroll="" href="#the-solution"><h5><i>1.2 &nbsp; The Solution</i></h5></a><a class="section" data-scroll="" href="#example"><h5><i>1.3 &nbsp; Example</i></h5></a></li><li><a class="chapter" data-scroll="" href="#query"><h4>2 &nbsp; query</h4></a><a class="section" data-scroll="" href="#paths"><h5><i>2.1 &nbsp; Paths</i></h5></a><a class="section" data-scroll="" href="#classes"><h5><i>2.2 &nbsp; Classes</i></h5></a></li><li><a class="chapter" data-scroll="" href="#mock-change-event"><h4>3 &nbsp; mock-change-event</h4></a></li>
                </ul>
              </nav>
          </div>
          <div><span id="introduction"></span><h2><b>1 &nbsp;&nbsp; Introduction</b></h2></div><div><p><a href='http://reagent-project.github.io'>Reagent</a> is a ClojureScript library that wraps <a href='https://reactjs.org'>React</a>, and makes it even more awesome by leveraging the power of Clojure's functional programming.</p></div><div><p>Reagent allows the client-side of a web application to consist of nothing but pure ClojureScript functions that map the <i>state</i>, stored in special atoms, to a <a href='https://github.com/weavejester/hiccup'>hiccup</a>-like representation of HTML. To make the application interactive, event handlers such as <code>on-click</code> or <code>on-change</code> can be assigned ClojureScript functions (closures),  which will be executed once the event fires.</p></div><div><span id="the-problem"></span><h3>1.1 &nbsp;&nbsp; The Problem</h3></div><div><p>Previous to ClojureScript, my last client-side experience involved <a href='https://angularjs.org'>AngularJS</a> (1.X). Although React (and Reagent) present an overall better programming model than Angular (IMHO), one thing is missing in React/Reagent,  and that's a coherent approach for unit-testing an application.</p></div><div><p>This was rather surprising and disapointing. After all, the code is reduced to pure ClojureScript functions, so why can't I just test them as functions?</p></div><div><p>The problem is that the data structure they emit &ndash; the hiccup-like vectors &ndash; are not so easy to test. Of course I can compare an entire vector to an expected one, but this will make me duplicate the code in the test, which is something I'd rather avoid. Furthermore, event handlers are functions, and their comparison is identity-based, meaning that even if I create the exact same event handler in the test, it will still test different than the one created by the function I'm testing.</p></div><div><span id="the-solution"></span><h3>1.2 &nbsp;&nbsp; The Solution</h3></div><div><p>This library is intended to provide functions to extract information from hiccup-like vectors. By being able to concisely query the returned vectors to extract the expected information we can write concise tests that exercise the component functions outside the full context of the application. After all, these are just functions. We can set values to atoms, call a function extract data and assert its value. We can extract event handlers and call them to see how they change the state, etc.</p></div><div><span id="example"></span><h3>1.3 &nbsp;&nbsp; Example</h3></div><div><p>In the following example we will show a piece of Reagent code and the associated tests, based on <code>reagent-query</code>.</p></div><div><p>The following component function takes as parameter an atom containing its state. The state consists of a sequence of "todo" tasks, given as maps, each containing a unique <code>:id</code> and a <code>:todo</code> string. The component creates a <code>:ul</code> with a <code>:li</code> for each task, with an <code>:input</code> box containing the text and a <code>:button</code> for deleting the task.</p></div><div class="code"><pre><code class="clojure">(defn todo [state]
  [:ul
   (for [{:keys [id todo]} @state]
     [:li {:key id}
      [:input {:value todo
               :on-change #(swap! state
                                  (partial map
                                           (fn [x]
                                             (if (= (:id x) id)
                                               (assoc x :todo (.-target.value %))
                                               x))))}]
      [:button {:on-click #(swap! state
                                  (partial filter
                                           (fn [x]
                                             (not= (:id x) id))))} &quot;Done&quot;]])])</code></pre></div><div><p>These are the tests:</p></div><div class="code"><pre><code class="clojure">todo-example
    ;; Empty list
    (let [state (atom [])]
      (is (= (-&gt; (todo state)
                 (rq/query :ul :li))
             [])))

    ;; The :id field should be the :li's :key attribute
    (let [state (atom [{:id 1 :todo &quot;One&quot;}
                       {:id 2 :todo &quot;Two&quot;}])]
      (is (= (-&gt; (todo state)
                 (rq/query :ul :li:key))
             [1 2])))

    ;; Each element includes an :input box with the :todo value as :value
    (let [state (atom [{:id 1 :todo &quot;One&quot;}
                       {:id 2 :todo &quot;Two&quot;}])]
      (is (= (-&gt; (todo state)
                 (rq/query :ul :li :input:value))
             [&quot;One&quot; &quot;Two&quot;])))

    ;; Each :li element has a :button with &quot;Done&quot; as text
    (let [state (atom [{:id 1 :todo &quot;One&quot;}
                       {:id 2 :todo &quot;Two&quot;}])]
      (is (= (-&gt; (todo state)
                 (rq/query :ul :li :button))
             [&quot;Done&quot; &quot;Done&quot;])))

    ;; The :on-click callback associated with each button deletes the respective entry in the atom
    (let [state (atom [{:id 1 :todo &quot;One&quot;}
                       {:id 2 :todo &quot;Two&quot;}])
          callbacks (-&gt; (todo state)
                        (rq/query :ul :li :button:on-click))]
      ;; Let's call the second callback
      ((second callbacks))
      ;; Now we should only have &quot;One&quot;
      (is (= (-&gt; (todo state)
                 (rq/query :ul :li :input:value))
             [&quot;One&quot;])))

    ;; The :on-change callback of the :input box update the :todo of that entry
    (let [state (atom [{:id 1 :todo &quot;One&quot;}
                       {:id 2 :todo &quot;Two&quot;}])
          callbacks (-&gt; (todo state)
                        (rq/query :ul :li :input:on-change))]
      ;; Let's call the first callback with a mock event modifying the value to &quot;Three&quot;
      ((first callbacks) (rq/mock-change-event &quot;Three&quot;))
      ;; Now we should have &quot;Three&quot; instead of &quot;One&quot;
      (is (= (-&gt; (todo state)
                 (rq/query :ul :li :input:value))
             [&quot;Three&quot; &quot;Two&quot;])))</code></pre></div><div><span id="query"></span><h2><b>2 &nbsp;&nbsp; query</b></h2></div><div><p><code>query</code> is given a hiccup-like vector and zero or more additional arguments, and returns a sequence of results.</p></div><div><p>The idea comes from <a href='https://jquery.com'>jQuery</a>, where the <code>$</code> function (among other things) acts as a query function, returning a sequence of results based on the given path. Our <code>query</code> function is intended to do the same, based on a given hiccup-like vector.</p></div><div><p>When given no extra arguments, <code>query</code> returns a single result: the given vector.</p></div><div class="code"><pre><code class="clojure">q1
    (is (= (rq/query [:div &quot;foo&quot; &quot;bar&quot;]) [[:div &quot;foo&quot; &quot;bar&quot;]]))</code></pre></div><div><p>When given an extra keyword argument matching the element type (the first element in the vector), the child elements are returned.</p></div><div class="code"><pre><code class="clojure">q2
    (is (= (rq/query [:div &quot;foo&quot; &quot;bar&quot;] :div) [&quot;foo&quot; &quot;bar&quot;]))</code></pre></div><div><p>If the extra parameter does not match the element type, an empty sequence is returned.</p></div><div class="code"><pre><code class="clojure">q3
    (is (= (rq/query [:div &quot;foo&quot; &quot;bar&quot;] :p) []))</code></pre></div><div><p>According to hiccup's convention, if the vector's second element is a map, it represents <i>attributes</i> for the element. If the extra argument is a keyword of the form <code>:elem:attr</code>, and if the <code>:elem</code> part matches the element, the value of the attribute <code>:attr</code> is returned.</p></div><div class="code"><pre><code class="clojure">q4
    (is (= (rq/query [:div {:id &quot;x&quot;} &quot;foo&quot; &quot;bar&quot;] :div:id) [&quot;x&quot;]))</code></pre></div><div><p>If the second part of the keyword does not match an attribute, <code>nil</code> is added to the sequence.</p></div><div class="code"><pre><code class="clojure">q5
    (is (= (rq/query [:div {:id &quot;x&quot;} &quot;foo&quot; &quot;bar&quot;] :div:not-an-attr) [nil]))</code></pre></div><div><p>If the first part of the keyword does not match the element, an empty sequence is returned.</p></div><div class="code"><pre><code class="clojure">q6
    (is (= (rq/query [:div {:id &quot;x&quot;} &quot;foo&quot; &quot;bar&quot;] :p:id) []))</code></pre></div><div><p>The attribute map is ignored when returning the contents of an element.</p></div><div class="code"><pre><code class="clojure">q7
    (is (= (rq/query [:div {:id &quot;x&quot;} &quot;foo&quot; &quot;bar&quot;] :div) [&quot;foo&quot; &quot;bar&quot;]))</code></pre></div><div><p>If an element is a sequence (e.g., created with a <code>for</code>), we operate on all its elements and concatenate the results.</p></div><div class="code"><pre><code class="clojure">q8
    (is (= (rq/query [:ul
                      [:li {:key -1}]
                      (for [i (range 3)]
                        [:li {:key i}])] :ul :li:key) [-1 0 1 2]))</code></pre></div><div><span id="paths"></span><h3>2.1 &nbsp;&nbsp; Paths</h3></div><div><p>Every additional argument is applied to all the results of applying the previous argument. For example, if we have a <code>:ul</code> element containing multiple <code>:li</code> elements, each containing a <code>:p</code> element and some text, The path <code>:ul :li :p</code> will return a sequence of the strings.</p></div><div class="code"><pre><code class="clojure">q-agg1
    (is (= (rq/query [:ul
                      [:li [:p &quot;One&quot;]]
                      [:li [:p &quot;Two&quot;]]
                      [:li [:p &quot;Three&quot;]]] :ul :li :p) [&quot;One&quot; &quot;Two&quot; &quot;Three&quot;]))</code></pre></div><div><span id="classes"></span><h3>2.2 &nbsp;&nbsp; Classes</h3></div><div><p>When a path element starts with a dot (<code>.</code>), it is treated as a class matcher. This means that it is expected to match against elements that have a <code>:class</code> attribute that includes the given class name. For example, in the following example only "Two" has the class <code>selected</code>, hence it is the only one to be returned.</p></div><div class="code"><pre><code class="clojure">q-cls1
    (is (= (rq/query [:ul
                      [:li {:class &quot;other&quot;} [:p &quot;One&quot;]]
                      [:li {:class &quot;other selected&quot;} [:p &quot;Two&quot;]]
                      [:li [:p &quot;Three&quot;]]] :ul :.selected :p) [&quot;Two&quot;]))</code></pre></div><div><p>The keyword can match at the same time against an element type and any number of classes. For example, the keyword <code>:li.foo.bar</code> matches against <code>:li</code> elements that have both the <code>foo</code> and the <code>bar</code> classes.</p></div><div class="code"><pre><code class="clojure">q-cls2
    (is (= (rq/query [:ul
                      [:li {:class &quot;foo&quot;} [:p &quot;One&quot;]]
                      [:li {:class &quot;bar&quot;} [:p &quot;Two&quot;]]
                      [:li {:class &quot;bar foo&quot;} [:p &quot;Three&quot;]]] :ul :li.foo.bar :p) [&quot;Three&quot;]))</code></pre></div><div><p>Classes can be used in conjunction with attributes.</p></div><div class="code"><pre><code class="clojure">q-cls3
    (is (= (rq/query [:div
                      [:a {:href &quot;foo.html&quot;}]
                      [:a {:href &quot;bar.html&quot; :class &quot;selected&quot;}]
                      [:a {:href &quot;baz.html&quot;}]] :div :a.selected:href) [&quot;bar.html&quot;]))</code></pre></div><div><span id="mock-change-event"></span><h2><b>3 &nbsp;&nbsp; mock-change-event</b></h2></div><div><p><code>mock-change-event</code> is a conveniece function that creates a mock <code>:on-change</code> event. The function takes as parameter a new value, and generates a Javascript object that has a single member: <code>target</code>, which by itself is a Javascript object with one field: <code>value</code>, containing the given value.</p></div><div class="code"><pre><code class="clojure">mce1
    (let [ev (rq/mock-change-event &quot;val&quot;)]
      (is (= (.-target.value ev) &quot;val&quot;)))</code></pre></div>
        </div>
      </div>
    </div>

    <label for="sidebar-checkbox" class="sidebar-toggle"></label>

  </body>

  <script>
  if (false) {
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
    ga('create', '<@=tracking>', 'caudate.me');
    ga('send', 'pageview');
  }
  </script>
  
  <script type="text/javascript">
    smoothScroll.init();
    gumshoe.init({});
  
    hljs.registerLanguage("clojure",function(e){var t={"builtin-name":"def defonce cond apply if-not if-let if not not= = < > <= >= == + / * - rem quot neg? pos? delay? symbol? keyword? true? false? integer? empty? coll? list? set? ifn? fn? associative? sequential? sorted? counted? reversible? number? decimal? class? distinct? isa? float? rational? reduced? ratio? odd? even? char? seq? vector? string? map? nil? contains? zero? instance? not-every? not-any? libspec? -> ->> .. . inc compare do dotimes mapcat take remove take-while drop letfn drop-last take-last drop-while while intern condp case reduced cycle split-at split-with repeat replicate iterate range merge zipmap declare line-seq sort comparator sort-by dorun doall nthnext nthrest partition eval doseq await await-for let agent atom send send-off release-pending-sends add-watch mapv filterv remove-watch agent-error restart-agent set-error-handler error-handler set-error-mode! error-mode shutdown-agents quote var fn loop recur throw try monitor-enter monitor-exit defmacro defn defn- macroexpand macroexpand-1 for dosync and or when when-not when-let comp juxt partial sequence memoize constantly complement identity assert peek pop doto proxy defstruct first rest cons defprotocol cast coll deftype defrecord last butlast sigs reify second ffirst fnext nfirst nnext defmulti defmethod meta with-meta ns in-ns create-ns import refer keys select-keys vals key val rseq name namespace promise into transient persistent! conj! assoc! dissoc! pop! disj! use class type num float double short byte boolean bigint biginteger bigdec print-method print-dup throw-if printf format load compile get-in update-in pr pr-on newline flush read slurp read-line subvec with-open memfn time re-find re-groups rand-int rand mod locking assert-valid-fdecl alias resolve ref deref refset swap! reset! set-validator! compare-and-set! alter-meta! reset-meta! commute get-validator alter ref-set ref-history-count ref-min-history ref-max-history ensure sync io! new next conj set! to-array future future-call into-array aset gen-class reduce map filter find empty hash-map hash-set sorted-map sorted-map-by sorted-set sorted-set-by vec vector seq flatten reverse assoc dissoc list disj get union difference intersection extend extend-type extend-protocol int nth delay count concat chunk chunk-buffer chunk-append chunk-first chunk-rest max min dec unchecked-inc-int unchecked-inc unchecked-dec-inc unchecked-dec unchecked-negate unchecked-add-int unchecked-add unchecked-subtract-int unchecked-subtract chunk-next chunk-cons chunked-seq? prn vary-meta lazy-seq spread list* str find-keyword keyword symbol gensym force rationalize"},r="a-zA-Z_\\-!.?+*=<>&#'",n="["+r+"]["+r+"0-9/;:]*",a="[-+]?\\d+(\\.\\d+)?",o={b:n,r:0},s={cN:"number",b:a,r:0},i=e.inherit(e.QSM,{i:null}),c=e.C(";","$",{r:0}),d={cN:"literal",b:/\b(true|false|nil)\b/},l={b:"[\\[\\{]",e:"[\\]\\}]"},m={cN:"comment",b:"\\^"+n},p=e.C("\\^\\{","\\}"),u={cN:"symbol",b:"[:]{1,2}"+n},f={b:"\\(",e:"\\)"},h={eW:!0,r:0},y={k:t,l:n,cN:"name",b:n,starts:h},b=[f,i,m,p,c,u,l,s,d,o];return f.c=[e.C("comment",""),y,h],h.c=b,l.c=b,{aliases:["clj"],i:/\S/,c:[f,i,m,p,c,u,l,s,d]}});
    hljs.initHighlightingOnLoad();
  </script>
</html>
